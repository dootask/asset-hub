---
description: Graphiti 知识图谱 / MCP 作为 AI 记忆层的使用说明与约束（本仓库专用）
globs: ["**/*"]
alwaysApply: true
---

## 1. 角色与范围

- 本规则文件约束的是：**在本仓库中，AI 助手如何通过 Graphiti 的 MCP 工具使用“知识图谱记忆层”**。  
- Graphiti 在这里主要承担两类角色：
  - 作为 **AI 的长期记忆库**：存放项目约束、用户偏好、通用流程（第一层记忆），便于跨会话复用。
  - （未来可选）作为 **业务侧知识图谱引擎**：服务于资产/公司/人员/操作等实体关系建模 —— 这部分将另行在 `41-graphiti-asset-hub.mdc` 中规划。
- 当前本仓库在 Graphiti 中使用的 `group_id` 已在 `00-project-overview.mdc` 中说明：**`dootask-plugin-asset-hub`**。

> **注意**：  
> - `.cursor/rules/*.mdc` 仍然是“本仓库的显式规则源”；  
> - Graphiti 是“跨对话 / 跨仓库可复用的长期记忆库”，两者互补，不互相替代。

---

## 2. 节点类型在本仓库中的含义

在本项目里，Graphiti 中常用的节点类型含义约定如下：

- **Preference（偏好 / 风格）**
  - 用户的个人偏好：例如“回答统一使用中文”、“尽量简洁但信息密度高”等。
  - 项目层面偏好：例如“前后端统一使用 TypeScript”、“优先使用 Next.js Route Handlers，而不是单独 Koa/Express 服务”等。

- **Procedure（流程 / 做事方式）**
  - 在本仓库开发时约定的“工作步骤”：  
    - 如“新增重要业务模块前，先补 `.cursor/rules` 设计文档，再写代码”；  
    - “数据库结构变更必须同步更新 `scripts/migrate.ts` 并执行 `pnpm migrate` + `pnpm test` 验证”等。
  - 也可以记录对用户特别重要的“操作说明流程”（例如交付到 DooTask 应用市场的步骤）。

- **Requirement（约束 / 需求）**
  - 关键架构 / 业务约束：  
    - 如“所有对外页面和 HTTP API 必须挂载在 `/apps/asset-hub` 前缀下”；  
    - “审批状态机仅使用 {draft, pending, approved, rejected, cancelled} 这些状态值”；
    - “资产相关接口优先通过 Next.js Route Handlers 实现”等。
  - 中长期的产品需求：比如“首页必须展示资产/公司/角色三个核心 KPI”。

Graphiti 中存的 Preference / Procedure / Requirement 应该与 `.cursor/rules` 保持一致：  
**当两者冲突时，以 `.cursor/rules` 为准，并据此更新 Graphiti 记忆。**

---

## 3. 使用 Graphiti 前必须先做的事（搜索）

在本仓库中，每次开始一项“非纯回答型”的任务前，AI 助手应：

1. **优先读取 `.cursor/rules/*.mdc`**  
   - 包括但不限于：`00-project-overview.mdc`、`10-dootask-plugin.mdc`、`20-web.mdc`、`21-web-routing.mdc`、`30-feature-plan.mdc`、`40-workflow-approval.mdc` 等。  
   - 规则文件是本项目最权威的约束来源。

2. **再使用 Graphiti 的搜索能力补充上下文**（工具名以实际 MCP 暴露为准）：
   - 使用节点搜索（`search_nodes` 或等价接口）：
     - 过滤 `entity_type` 为 `Preference`、`Procedure` 或 `Requirement`；
     - 查询与当前任务相关的项目偏好、流程和约束（例如 “asset-hub web routing”、“approval workflow” 等关键词）。
   - 使用事实搜索（`search_facts` 或等价接口）：
     - 查找与当前实体相关的关系 / 事实，例如“Asset Hub 项目与 Next.js 的关系”、“审批与 DooTask 待办的关联”等。

3. **认真审阅匹配结果**  
   - 若发现与当前任务高度相关的 Preference/Procedure/Requirement，应在后续操作中显式遵守。  
   - 若 Graphiti 与 `.cursor/rules` 有不一致，以 `.cursor/rules` 为准，并在需要时更新 Graphiti（见下文 §4）。

---

## 4. 什么时候要把新信息写入 Graphiti

在本仓库工作时，满足以下任一条件时，应使用 Graphiti 的写入类工具（例如 `add_memory` / `update_memory` 等）更新图谱：

- **用户表达了新的长期偏好（Preference）**
  - 如：“以后回答都尽量用表格对比”、“优先给出分阶段计划再写代码”等。

- **形成了可复用的工作流程（Procedure）**
  - 如：“在 Asset Hub 中新增审批流程的标准步骤”；  
  - “发布到 DooTask 应用市场的固定流水线”；  
  - “在本项目中调试数据库问题的标准排障步骤”等。

- **确立了新的重要约束/需求（Requirement）**
  - 如：“审批流程必须通过 `/api/approvals` 系列接口暴露”；  
  - “图谱功能统一使用 `group_id = dootask-plugin-asset-hub`”；  
  - “所有资产 API 必须在响应中带上 `meta` 分页信息”等。

写入时的注意事项：

- **拆小块**：对于很长的需求/流程，应拆成多条逻辑清晰的短记忆，以便将来精确检索。
- **更新而不是重复**：如果只是对已有记忆的修改，优先使用更新接口，而不是新增一条语义相近的节点。
- **标注好类型与类别**：明确这是 Preference / Procedure / Requirement，并尽量附上简洁的分类标签（如 `web-routing`、`approvals`、`dootask-integration` 等）。

---

## 5. 工作过程中如何使用 Graphiti 的记忆

在具体执行任务时，AI 助手应遵循：

- **尊重已存偏好（Preferences）**
  - 回答风格、语言、技术选型等要与已知偏好保持一致，除非用户明确要求改变。

- **遵循既有流程（Procedures）**
  - 若 Graphiti 中已存在与当前任务高度匹配的 Procedure（例如“如何新增一个 API Route Handler”），应尽量按该流程执行，不随意改变顺序。

- **应用相关事实（Facts / Requirements）**
  - 在设计路由、数据结构、审批状态机等时，应优先查阅并遵守已存的 Requirement 和 Facts。

- **保持一致性**
  - 若某次任务需要暂时偏离既有流程或偏好，应在对话中向用户说明原因，并在用户确认后再执行；
  - 如该偏离将成为新的常态，应在任务结束后更新 Graphiti 记忆。

---

## 6. 与现有工具与规则的关系

- **与 `.cursor/rules` 的关系**
  - `.cursor/rules/*.mdc` 是本仓库的“显式规则源”，优先级更高；
  - Graphiti 记忆用于补充历史背景、用户偏好与跨仓库可复用经验；
  - 当 Graphiti 与 `.cursor/rules` 有冲突时，**必须以 `.cursor/rules` 为准**，并在必要时同步更新 Graphiti 中的相关节点。

- **与本环境的 `update_memory` 工具的关系**
  - 当用户明确要求“记住某件事 / 偏好 / 规则”时，应调用当前环境提供的 `update_memory` / `add_memory` 工具；
  - 在调用时，应尽量遵循本文件第 2 节的类型划分（Preference / Procedure / Requirement），并附上合理的分类标签；
  - 具体底层是否通过 Graphiti 落库由宿主环境决定，本规则只约束“应该记什么、如何分类”。

---

## 7. 最佳实践小结

- **先查再做**：在提出解决方案或改动架构前，优先查阅 `.cursor/rules` 与 Graphiti 中已有的设计和约束。
- **能复用就沉淀**：只要发现某个偏好/流程/约束未来还会经常用到，就尽快写入 Graphiti，而不是只放在当前对话里。
- **保持项目内外一致**：本仓库中的 Graphiti 记忆应始终与 `.cursor/rules`、实际代码状态保持同步，避免“记忆漂移”。

只要遵守以上规则，Graphiti 就可以在本项目中稳定地扮演“第二大脑”的角色，为后续迭代、协作开发提供长期、一致的知识支撑。

